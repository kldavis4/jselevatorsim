var Elevator = require('../lib/elevator');

//Elevator simulation
// Instantiate with number of elevators and number of floors
module.exports = function (numElevators, numFloors) {
    'use strict';
    var elevators = [],
        i;

    //Handles messages generated by the elevators
    function handleMessage(msg) {
        console.log(msg);
    }

    //Initializes elevator objects
    for (i = 0; i < numElevators; i += 1) {
        elevators.push(new Elevator(i, numFloors, handleMessage));
    }

    //Define function to handle a set of call requests
    this.processCallRequests = function (callsMap) {
        var time = 0,
            calls,
            j;

        //Reset all elevators
        for (i = 0; i < numElevators; i += 1) {
            elevators[i].reset();
        }

        while (true) {
            //Get call for current time
            calls = callsMap[time];

            //Each elevator broadcasts its state to all the other elevators
            for (i = 0; i < numElevators; i += 1) {
                elevators[i].broadcastState(elevators);
            }

            var rejectedCalls = [];
            //Send call request
            for (i = 0; i < numElevators; i += 1) {
                for (j = 0; calls && calls.length > 0; j += 1) {
                    //Receive the call requests
                    if ( !elevators[i].receiveMessage({
                        type: 'CALL',
                        startFloor: calls[j].startFloor,
                        endFloor: calls[j].endFloor
                    }) ) {
                        //Handle rejected message - only need to do this for the
                        //first elevator since they all share the same election logic
                        if (i === 0) {
                            //Add the call to list of rejected calls
                            rejectedCalls.add(calls[j]);
                        }
                    };
                }

                //Advance state of elevator
                elevators[i].tick();
            }

            //Iterate the rejected calls list and add the rejected calls
            //to the callsMap at the next available time so they can be retried
            for (i = 0; i < rejectedCalls.length; i++) {
                if (!callsMap[time+1]) {
                    callsMap[time+1] = [];
                }

                callsMap[time+1].push(rejectedCalls[i]);
            }

            //Advance time counter
            time += 1;
        }
    };
};
